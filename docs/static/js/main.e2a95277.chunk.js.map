{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","class","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","setTimeout","useFetchGifs","console","log","className","GifExpertApp","categories","document","querySelector","ReactDOM","render","getElementById"],"mappings":"iNAIaA,EAAc,SAAC,GAAqB,IAApBC,EAAmB,EAAnBA,cAG7B,EAAoCC,qBAApC,mBAAOC,EAAP,KAAmBC,EAAnB,KAmBI,OAGI,cAFA,CAEA,QAAMC,SAbO,SAACC,GAEdA,EAAEC,iBAEEJ,EAAWK,OAAOC,OAAS,IAC3BR,GAAc,SAAAS,GAAI,OAAKP,GAAL,mBAAoBO,OACtCN,EAAc,MAOlB,UACI,mCAAOD,KACP,uBAAOQ,KAAK,OACLC,MAAOT,EACPU,SAvBO,SAACP,GACvBF,EAAcE,EAAEQ,OAAOF,c,+BCRbG,EAAO,uCAAG,WAAMC,GAAN,uBAAAC,EAAA,6DAGdC,EAHc,iDAGkCC,UAAUH,GAH5C,+DAMDI,MAAMF,GANL,cAMdG,EANc,gBAUFA,EAAKC,OAVH,uBAUhBC,EAVgB,EAUhBA,KAIFC,EAAOD,EAAKE,KAAK,SAAAC,GAAQ,IAAD,EAC1B,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MAEXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAnBlB,kBAuBZM,GAvBY,4CAAH,sDCDRO,EAAc,SAAC,GAAoB,IAAlBb,EAAiB,EAAjBA,IAAKU,EAAY,EAAZA,MAC/B,OACI,sBAAKI,MAAM,yBAAX,UACI,qBAAKC,IAAKf,EAAKgB,IAAKN,IACpB,4BAAIA,QCFHO,EAAU,SAAC,GAAgB,IAAfnB,EAAc,EAAdA,SAIrB,ECFyB,SAACA,GACzB,MAA0Bd,mBAAS,CAChCqB,KAAM,GACNa,SAAS,IAFZ,mBAAOC,EAAP,KAAcC,EAAd,KA8BC,OAtBDC,qBAAU,WAETxB,EAASC,GACPwB,MAAM,SAAAC,GAELC,YAAY,WACTJ,EAAS,CACLf,KAAMkB,EACVL,SAAS,MAET,UAIJ,CAACpB,IAQIqB,ED7BoBM,CAAc3B,GAA/Ba,EAAZ,EAAON,KAAYa,EAAnB,EAAmBA,QAmBnB,OAjBAQ,QAAQC,MAkBJ,qCACA,oBAAIC,UAAU,kBAAd,SAAiC9B,IACjC,sBAAKgB,MAAM,YAAX,UAEOI,GAAW,cA2BbP,EAAOJ,KAAI,SAAAgB,GAAI,OACZ,cAAC,EAAD,eAEIA,GAFcA,EAAKd,cErBxBoB,EAnCM,WAEjB,MAAoC7C,mBAAS,CAAC,cAA9C,mBAAO8C,EAAP,KAAmB/C,EAAnB,KAEA,OAEI,qCACA,oBAAI6C,UAAU,sBAAd,0BAEA,cAAE,EAAF,CAAc7C,cAAeA,IAE5B,uBAID,6BAEQ+C,EAAWvB,KAAI,SAAAT,GAAQ,OACnB,cAAC,EAAD,CAAwBA,SAAUA,GAApBA,YCflBiC,SAASC,cAAc,SAEvCC,IAASC,OAEL,cAAC,EAAD,IAEFH,SAASI,eAAe,W","file":"static/js/main.e2a95277.chunk.js","sourcesContent":["import React, {useState} from 'react'\r\nimport PropTypes from 'prop-types';\r\n\r\n\r\nexport const AddCategory = ({setCategories}) => {\r\n\r\n// en este ejercicio el inputValue guarda el ultimo valor que escribimos, esto hace que se vea en el input y en el h2\r\nconst [inputValue, setInputValue] = useState();\r\n\r\n// el handleInputChange es un evento que hace que esta funcion cambie el ultimo valor que escribimos\r\nconst handleInputChange = (e) =>{\r\n    setInputValue(e.target.value);\r\n\r\n    \r\n}\r\n\r\nconst handleSubmit = (e) =>{\r\n    // este metodo hace que la pagina no se recargue por completo\r\n        e.preventDefault();\r\n        // esto hace que no envie valor vacio o repetidos\r\n        if (inputValue.trim().length > 2 ) {\r\n            setCategories(cats => [inputValue, ...cats ]);\r\n            setInputValue('');\r\n        }\r\n        \r\n    }\r\n    return (\r\n        /* aqui podemos dejar solo el form ya que solo estamos retornando un solo elemento\r\n        el form agrupa todos los elementos por ente solo esta retornando un nelemento  */\r\n        <form onSubmit={ handleSubmit }> \r\n            <h2> { inputValue }</h2>\r\n            <input type=\"text\"\r\n                   value={inputValue}\r\n                   onChange={ handleInputChange}\r\n            \r\n            />\r\n        </form>\r\n    )\r\n}\r\n\r\nAddCategory.propTypes ={\r\n    setCategories: PropTypes.func.isRequired,\r\n}\r\n","\r\n\r\n // el await solo sirve dentro de la funcion async (significa asincrono)\r\nexport  const getGifs = async(category) =>{\r\n \r\n    // el aqui metemos el url del postman\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=10&api_key=OMiXoC35cGBjOE62O5agYdb6Fk501Lm1`;\r\n     \r\n    // await significa esperar y fetch es respuesta basicamente estamos esperando la respuesta del url si es correcta\r\n    const resp = await fetch(url);\r\n    \r\n// el postman envia en formato json por ende aqui estamos esperando que llegue la respuesta en formato Json\r\n// metemos el data dentro de llaves para destructurarla\r\nconst { data }= await resp.json();\r\n\r\n\r\n// aqui por lo que entendi estamos barriendo lo que no nos sirve y retornando los valores requeridos en un objeto\r\nconst gifs = data.map( img => {\r\n    return {\r\n        id: img.id,\r\n        title: img.title,\r\n        // el signo de interrogacion es para preguntar si esta recibiendo la imagen \r\n        url: img.images?.downsized_medium.url\r\n    }\r\n})\r\n\r\n     return gifs;\r\n\r\n }","import React from 'react'\r\n\r\nexport const GifGridItem = ( {url, title} ) => {\r\n    return (\r\n        <div class=\"card animate__bounceIn\">\r\n            <img src={url} alt={title} />\r\n            <p>{title}</p>\r\n        </div>\r\n    )\r\n}\r\n","import React from 'react';\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\n import {GifGridItem} from './GifGridItem'\r\n\r\nexport const GifGrid = ({category}) => {\r\n\r\n\r\n\r\n    const {data:images,loading}= useFetchGifs( category );\r\n\r\n    console.log();\r\n\r\n\r\n    /* const [images, setImages] = useState([])\r\n    \r\n\r\n// el useaEffect hace que solo se ejecute una vez el getgifs\r\n// ya que sin esto se ejecutara infinitamente la funcion cada que se haga un cambio\r\n    useEffect( () => {\r\n\r\n        getGifs(category)\r\n            .then( setImages)\r\n        //las [] sirven para que capture una sola vez la funcion y no se ejectute infinitamente\r\n    }, [category])\r\n\r\n */\r\n     \r\n    return (\r\n        <>\r\n        <h2 className='animate__shakeX'>{category}</h2>\r\n        <div class=\"card-grid\">\r\n\r\n             { loading && 'Cargando...'}\r\n\r\n               {\r\n               \r\n              \r\n               \r\n               \r\n               /* \r\n               \r\n                ESTO ES UN EJERCICIO QUE NO RESILVI BIEN, OJO APRENDER O MEMORIZAR\r\n               \r\n               {\r\n        // este ejercicio no logre hacerlo, aprender bien el uso de esta funcion\r\n        // estamos llamando del usestate el imagen y mapeamos con el map, colocamos un argumento img\r\n\r\n            //        images.map(img =>  (\r\n        // como estamos en una lista dentro del <li></li> el key en este caso es {img.id} ya que no mapeamos\r\n        // si fueramos mapeado pasamos comoa rgumentos los valores del useState\r\n                    <li key={img.id} >{img.title} </li>\r\n         //           ))\r\n                }\r\n */            \r\n \r\n\r\n\r\n                // ESTA SERIE OTRA FORMA MEJOR DE HACER EL EJERCICIO DE ARRIBA\r\n\r\n             images.map(imgs =>(\r\n                <GifGridItem key={imgs.id} \r\n                // operador exprect del img\r\n                {...imgs} />\r\n\r\n            ))\r\n\r\n\r\n\r\n               }\r\n            \r\n            \r\n            \r\n        </div>\r\n        </>\r\n    )\r\n}\r\n"," // todos los hooks empiezan con usea, bien sea useState, useFetch etc\r\n // los use son solo funciones\r\n \r\n import  {useEffect, useState} from 'react';\r\n import {getGifs} from '../helpers/getGifs'\r\n\r\n export const useFetchGifs = (category) => {\r\n     const [state, setState] = useState({\r\n        data: [],\r\n        loading: true\r\n\r\n       \r\n\r\n     });\r\n\r\n     useEffect(()=>{\r\n       \r\n      getGifs( category)\r\n       .then( imgs =>{\r\n\r\n         setTimeout( () => {\r\n            setState({\r\n                data: imgs,\r\n            loading: false\r\n            })\r\n         }, 3000 );\r\n\r\n       } )\r\n\r\n     }, [category] )\r\n\r\n     \r\n\r\n \r\n\r\n\r\n     // aqui estoy retornando un objeto del argumento state de arriba, este state puede tener cualquier otro nombre\r\n      return state;\r\n    }","import React, {useState} from 'react';\r\nimport {AddCategory} from './components/AddCategory'\r\nimport {GifGrid} from './components/GifGrid'\r\n\r\nconst GifExpertApp = () => {\r\n\r\n    const [categories, setCategories] = useState(['One Piece']);\r\n\r\n    return (\r\n\r\n        <>\r\n        <h1 className='animate__backInDown'>GifExpertApp</h1>\r\n\r\n        < AddCategory setCategories={setCategories} />\r\n\r\n         <hr></hr>\r\n        \r\n\r\n\r\n        <ol>\r\n            {\r\n                categories.map(category =>(\r\n                    <GifGrid key={category} category={category} />\r\n                 ))\r\n            }\r\n        </ol>\r\n        </>\r\n\r\n    )\r\n\r\n\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport default GifExpertApp;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport GifExpertApp from './GifExpertApp'\n\n\n// eslint-disable-next-line no-unused-vars\nconst divRoot = document.querySelector('#root');\n\nReactDOM.render(\n\n    <GifExpertApp />,\n\n  document.getElementById('root')\n);\n"],"sourceRoot":""}